<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>乱数表（ダブルス／シングルス）</title>

<link rel="manifest" href="manifest.json">
<meta name="theme-color" content="#111827">
<link rel="apple-touch-icon" href="icon-192.svg">

<style>
/* ===== ベース ===== */
body{font-family:system-ui,-apple-system,"Segoe UI",sans-serif;margin:0;background:#f6f7f9}
header{background:#111827;color:#fff;padding:14px}
header h1{margin:0;font-size:18px}
main{max-width:980px;margin:auto;padding:16px}

.card{background:#fff;border-radius:12px;padding:14px;margin-bottom:12px;box-shadow:0 2px 8px rgba(0,0,0,.08)}
.row{display:flex;gap:12px;flex-wrap:wrap;align-items:flex-end}
.field{flex:1 1 160px}
label{font-size:12px;color:#374151;display:block;margin-bottom:6px}
input,select,button{width:100%;padding:10px;border-radius:10px;border:1px solid #d1d5db;font:inherit;background:#fff}
button.primary{background:#111827;color:#fff;border:none;cursor:pointer}
button.ghost{cursor:pointer}

.round{border:1px solid #e5e7eb;border-radius:12px;padding:12px;margin:12px 0}
.round-title{font-weight:900;margin-bottom:10px}
.subhead{font-weight:900;margin:10px 0 6px}

table{width:100%;border-collapse:collapse}
th,td{border-top:1px solid #e5e7eb;padding:12px;vertical-align:middle}
th{width:120px;text-align:left;color:#374151;font-weight:800}

.match{display:flex;align-items:center;gap:12px;flex-wrap:wrap}
.pair{display:flex;align-items:center;gap:8px}
.box-male{
  display:inline-flex;align-items:center;justify-content:center;
  min-width:48px;padding:10px 14px;border:3px solid #000;border-radius:12px;
  color:#2563eb;font-size:26px;font-weight:900;line-height:1
}
.box-female{
  display:inline-flex;align-items:center;justify-content:center;
  min-width:48px;padding:10px 14px;border:3px solid #000;border-radius:12px;
  color:#dc2626;font-size:26px;font-weight:900;line-height:1
}
.box-rest{
  display:inline-flex;align-items:center;justify-content:center;
  min-width:48px;padding:10px 14px;border:3px dashed #9ca3af;border-radius:12px;
  color:#6b7280;font-size:22px;font-weight:900;font-style:italic;background:#f9fafb
}
.vs{font-weight:900;font-size:18px;margin:0 6px}

.small{font-size:12px;color:#6b7280}
.warn{font-size:13px;color:#b91c1c;margin-top:8px;white-space:pre-wrap}

.summary-title{font-weight:900;margin:12px 0 8px}
.pill{display:inline-flex;gap:8px;align-items:center;padding:8px 10px;border:1px solid #e5e7eb;border-radius:999px}

/* ===== モニター表示（全画面） ===== */
.monitor-overlay{position:fixed; inset:0; background:#0b1220; color:#fff; display:none; z-index:9999;}
.monitor-overlay.show{display:block;}
.monitor-top{display:flex; align-items:center; justify-content:space-between; padding:10px 12px; gap:10px; border-bottom:1px solid rgba(255,255,255,.15);}
.monitor-title{font-weight:900}
.monitor-hint{font-size:12px; opacity:.8}
.monitor-btns{display:flex; gap:8px; flex-wrap:wrap; align-items:center}
.monitor-btns button{
  width:auto; padding:10px 12px; border-radius:10px;
  border:1px solid rgba(255,255,255,.25);
  background:rgba(255,255,255,.08); color:#fff; cursor:pointer;
}
.monitor-btns button.primary{background:#fff;color:#111827;border:none}
.monitor-btns select{
  width:auto; padding:10px 12px; border-radius:10px;
  border:1px solid rgba(255,255,255,.25);
  background:rgba(255,255,255,.08); color:#fff;
}

/* ===== モニター：画面フィット（自動スケール） ===== */
.monitor-main{
  height:calc(100vh - 56px);
  overflow:hidden;
  display:flex;
  align-items:center;
  justify-content:center;
}
#monitorStage{
  width:100%;
  height:100%;
  display:flex;
  align-items:center;
  justify-content:center;
  padding:12px;
  box-sizing:border-box;
}
#monitorScale{
  transform-origin:center center;
  will-change:transform;
}
.monitor-main .round{
  max-width:none;
  margin:0;
  background:#fff;
  color:#111;
}

/* ===== モニター：遠目向けの強化（ただし折り返さない） ===== */
.monitor-main .round-title{font-size:26px}
.monitor-main th{font-size:18px; white-space:nowrap}
.monitor-main td{white-space:nowrap}              /* ★ここ重要：セル内を折り返さない */
.monitor-main .match{
  flex-wrap:nowrap;                               /* ★ここ重要：vsが回り込まない */
  justify-content:flex-start;
}
.monitor-main .pair{flex-wrap:nowrap}
.monitor-main .vs{font-size:22px; margin:0 10px; white-space:nowrap}
.monitor-main .box-male,
.monitor-main .box-female{
  font-size:34px;
  min-width:56px;
  padding:12px 16px;
}

/* ===== 2R表示：縦に2枚（上下） ===== */
.monitor-grid2{
  display:flex;
  flex-direction:column;
  gap:14px;
}

/* ===== スマホ横向き最適化 ===== */
@media (orientation: landscape) and (max-height: 520px) {
  header{padding:8px}
  header h1{font-size:14px}
  main{padding:10px}

  .card{padding:10px;margin-bottom:10px}
  th,td{padding:10px}

  .box-male,.box-female{
    font-size:28px;
    min-width:44px;
    padding:8px 12px;
    border-width:2px;
  }
  .vs{font-size:16px}
  .round-title{margin-bottom:8px}

  .monitor-top{padding:8px 10px}
  .monitor-hint{display:none}

  /* 横向きはさらに詰める（でも折り返し禁止は維持） */
  .monitor-main .vs{margin:0 8px}
}

/* ===== 印刷 ===== */
@media print{
  header,.controls,.monitor-overlay{display:none!important}
  main{max-width:none;padding:0}
  .card{box-shadow:none;border-radius:0}
  .round{break-inside:avoid}
}
</style>
</head>

<body>
<header>
  <h1>乱数表（ダブルス／シングルス）</h1>
</header>

<main>
  <div class="card controls">
    <div class="row">
      <div class="field">
        <label>種目</label>
        <select id="gameType">
          <option value="doubles" selected>ダブルス</option>
          <option value="singles">シングルス</option>
        </select>
      </div>

      <div class="field">
        <label>モード</label>
        <select id="mode">
          <option value="mixed" selected>混合</option>
          <option value="separate">男女別</option>
        </select>
      </div>

      <div class="field">
        <label>ラウンド数</label>
        <input type="number" id="rounds" value="10" min="1" max="80">
      </div>

      <div class="field" id="mixedCourtsBox">
        <label>コート数（混合）</label>
        <input type="number" id="mixedCourts" value="3" min="1" max="12">
      </div>

      <div class="field" id="boysCourtsBox" style="display:none">
        <label>男子コート数</label>
        <input type="number" id="boysCourts" value="2" min="0" max="12">
      </div>

      <div class="field" id="girlsCourtsBox" style="display:none">
        <label>女子コート数</label>
        <input type="number" id="girlsCourts" value="1" min="0" max="12">
      </div>

      <div class="field">
        <label>男（人数）</label>
        <input type="number" id="menCount" value="10" min="0" max="80">
      </div>

      <div class="field">
        <label>女（人数）</label>
        <input type="number" id="womenCount" value="10" min="0" max="80">
      </div>

      <div class="field" style="flex:1 1 220px">
        <label>試合数を均等化</label>
        <select id="balance">
          <option value="on" selected>ON（少ない人優先）</option>
          <option value="off">OFF（ランダム）</option>
        </select>
      </div>

      <div class="field" style="flex:1 1 280px">
        <label>重複回避</label>
        <select id="avoidMode">
          <option value="off">OFF（回避しない）</option>
          <option value="soft" selected>回避ON（できるだけ回避）</option>
          <option value="strict">完全禁止（破らない）</option>
        </select>
        <div class="small">
          ダブルス strict：同ペア完全禁止（埋まらなければ休）<br>
          シングルス strict：同一対戦（同じ相手）完全禁止（埋まらなければ休）
        </div>
      </div>

      <div class="field" id="mixedSinglesRuleBox" style="display:none;flex:1 1 260px">
        <label>混合シングルス・ルール</label>
        <select id="mixedSinglesRule">
          <option value="mf" selected>男 vs 女</option>
          <option value="any">性別不問（ランダム）</option>
          <option value="alt">交互（奇数R:男vs女 / 偶数R:不問）</option>
        </select>
      </div>
    </div>

    <div class="row" style="margin-top:12px">
      <div class="field"><button class="primary" onclick="generate()">生成</button></div>
      <div class="field"><button class="ghost" onclick="openMonitor()">モニター表示</button></div>
      <div class="field"><button class="ghost" onclick="window.print()">印刷</button></div>
    </div>

    <div id="status" class="warn"></div>
  </div>

  <div class="card">
    <div id="output"></div>
    <div id="summary"></div>
  </div>
</main>

<div id="monitor" class="monitor-overlay" aria-hidden="true">
  <div class="monitor-top">
    <div>
      <div class="monitor-title" id="monitorTitle">モニター表示</div>
      <div class="monitor-hint">← / → で切替、Escで終了</div>
    </div>
    <div class="monitor-btns">
      <button onclick="prevRound()">← 前へ</button>
      <button class="primary" onclick="nextRound()">次へ →</button>

      <select id="monitorView" onchange="setMonitorView(this.value)">
        <option value="1" selected>1R表示</option>
        <option value="2">2R表示</option>
      </select>

      <button onclick="toggleFullscreen()">全画面</button>
      <button onclick="closeMonitor()">閉じる</button>
    </div>
  </div>

  <div id="monitorMain" class="monitor-main">
    <div id="monitorStage">
      <div id="monitorScale"></div>
    </div>
  </div>
</div>

<script>
/* =========================
   ユーティリティ
========================= */
const makeList = n => Array.from({length:n}, (_,i)=>i+1);
const shuffle = a => { const b=a.slice(); for(let i=b.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [b[i],b[j]]=[b[j],b[i]]; } return b; };
const courtName = i => String.fromCharCode(65+i);

const boxMale = n => `<span class="box-male">${n}</span>`;
const boxFemale = n => `<span class="box-female">${n}</span>`;
const boxRest = () => `<span class="box-rest">休</span>`;

function initCounts(n){ const obj={}; for(let i=1;i<=n;i++) obj[i]=0; return obj; }
function addGames(counts, ids){ for(const id of ids){ if(id==null) continue; counts[id]=(counts[id]??0)+1; } }

function pickByLeastGames(list, counts, need, balanceOn){
  if(need<=0) return [];
  if(!balanceOn) return shuffle(list).slice(0, need);
  const groups = new Map();
  for(const id of list){
    const g = counts[id] ?? 0;
    if(!groups.has(g)) groups.set(g, []);
    groups.get(g).push(id);
  }
  const keys = Array.from(groups.keys()).sort((a,b)=>a-b);
  const picked=[];
  for(const k of keys){
    const bucket=shuffle(groups.get(k));
    for(const id of bucket){
      picked.push(id);
      if(picked.length>=need) return picked;
    }
  }
  return picked;
}

/* =========================
   キー（重複管理）
========================= */
const u = (a,b) => (a<b ? `${a}~${b}` : `${b}~${a}`);
const playerTok = (sex, n) => `${sex}${n}`;
const singlesKey = (p,q) => (p<q ? `${p}~${q}` : `${q}~${p}`);
const pairKeyMixed = (m,f) => `X:${m}|${f}`;
const pairKeySame  = (sex,a,b) => `${sex}:${u(a,b)}`;
const matchupKey = (A,B) => {
  const a = JSON.stringify(A), b = JSON.stringify(B);
  return (a<b) ? `${a}||${b}` : `${b}||${a}`;
};
const oppKey = (p,q) => (p<q ? `${p}~${q}` : `${q}~${p}`);

/* ===== strict：Hopcroft–Karp ===== */
function maxMatchingBipartite(menPool, womenPool, edgesAllowed){
  const adj = new Map();
  for(const m of menPool){
    const cand=[];
    for(const f of womenPool){
      if(edgesAllowed(m,f)) cand.push(f);
    }
    adj.set(m, cand);
  }
  const INF = 1e9;
  const pairU = new Map();
  const pairV = new Map();
  const dist = new Map();

  function bfs(){
    const q=[];
    for(const m of menPool){
      if(!pairU.has(m)){ dist.set(m, 0); q.push(m); }
      else dist.set(m, INF);
    }
    let found=false;
    while(q.length){
      const m=q.shift();
      for(const f of adj.get(m)){
        const m2 = pairV.get(f);
        if(m2 === undefined) found=true;
        else if(dist.get(m2) === INF){
          dist.set(m2, dist.get(m)+1);
          q.push(m2);
        }
      }
    }
    return found;
  }

  function dfs(m){
    for(const f of adj.get(m)){
      const m2 = pairV.get(f);
      if(m2 === undefined || (dist.get(m2) === dist.get(m)+1 && dfs(m2))){
        pairU.set(m,f);
        pairV.set(f,m);
        return true;
      }
    }
    dist.set(m, INF);
    return false;
  }

  while(bfs()){
    for(const m of menPool){
      if(!pairU.has(m)) dfs(m);
    }
  }

  const res=[];
  for(const [m,f] of pairU.entries()) res.push([m,f]);
  return res;
}

/* ===== strict：最大ペア数（一般） ===== */
function maxPairsGeneral(playersTokens, usedSet, keyFn){
  const ids = playersTokens.slice();
  const avail = new Map();
  for(const a of ids){
    const cand=[];
    for(const b of ids){
      if(a===b) continue;
      if(!usedSet.has(keyFn(a,b))) cand.push(b);
    }
    avail.set(a, cand);
  }
  const remaining = new Set(ids);
  let best=[];

  function pickNext(){
    let chosen=null, min=1e9;
    for(const a of remaining){
      let c=0;
      for(const b of avail.get(a)) if(remaining.has(b)) c++;
      if(c<min){ min=c; chosen=a; }
      if(min===0) break;
    }
    return chosen;
  }

  function dfs(current){
    const upper = current.length + Math.floor(remaining.size/2);
    if(upper <= best.length) return;

    if(remaining.size < 2){
      if(current.length > best.length) best = current.slice();
      return;
    }

    const a = pickNext();
    if(a==null){
      if(current.length > best.length) best = current.slice();
      return;
    }

    remaining.delete(a);
    dfs(current);
    remaining.add(a);

    for(const b of avail.get(a)){
      if(!remaining.has(b)) continue;
      remaining.delete(a); remaining.delete(b);
      current.push([a,b]);
      dfs(current);
      current.pop();
      remaining.add(a); remaining.add(b);
    }
  }

  dfs([]);
  return best;
}

/* ===== soft：試行 ===== */
function bestOfTries(makeCandidateFn, scoreFn, tries){
  let best=null, bestScore=Infinity;
  for(let t=0;t<tries;t++){
    const cand = makeCandidateFn();
    const s = scoreFn(cand);
    if(s < bestScore){ bestScore=s; best=cand; if(s===0) break; }
  }
  return best;
}

/* =========================
   表示ユーティリティ
========================= */
function wrapRound(r){
  const d=document.createElement("div");
  d.className="round";
  d.innerHTML = `<div class="round-title">第${r+1}ラウンド</div>`;
  return d;
}
function renderTableRows(courts, rowHtmlFn){
  const t=document.createElement("table"), tb=document.createElement("tbody");
  for(let c=0;c<courts;c++){
    const tr=document.createElement("tr");
    tr.innerHTML = `<th>${String.fromCharCode(65+c)}コート</th><td>${rowHtmlFn(c)}</td>`;
    tb.appendChild(tr);
  }
  t.appendChild(tb);
  return t;
}
function renderSummary(menGames, womenGames){
  const menArr = Object.entries(menGames).map(([k,v])=>({id:Number(k), games:v})).sort((a,b)=>a.id-b.id);
  const womenArr = Object.entries(womenGames).map(([k,v])=>({id:Number(k), games:v})).sort((a,b)=>a.id-b.id);

  const maxM = menArr.length ? Math.max(...menArr.map(x=>x.games)) : 0;
  const minM = menArr.length ? Math.min(...menArr.map(x=>x.games)) : 0;
  const maxW = womenArr.length ? Math.max(...womenArr.map(x=>x.games)) : 0;
  const minW = womenArr.length ? Math.min(...womenArr.map(x=>x.games)) : 0;

  const rowPills = (arr, type)=> arr.map(x=>{
    const box = type==="m" ? boxMale(x.id) : boxFemale(x.id);
    return `<span class="pill">${box}<b>${x.games}試合</b></span>`;
  }).join(" ");

  return `
    <div class="summary-title">試合数サマリー</div>
    <div class="small">男：最小 ${minM} / 最大 ${maxM}　｜　女：最小 ${minW} / 最大 ${maxW}</div>
    <div style="margin:10px 0 6px;font-weight:900;">男</div>
    <div style="display:flex;flex-wrap:wrap;gap:8px">${rowPills(menArr,"m")}</div>
    <div style="margin:12px 0 6px;font-weight:900;">女</div>
    <div style="display:flex;flex-wrap:wrap;gap:8px">${rowPills(womenArr,"w")}</div>
  `;
}

/* =========================
   生成本体（※ここは前版と同じロジック）
   省略せず全部入りにしたい場合は、あなたの直前コードの generate() をそのまま残してOK。
   （この回答では“モニター表示の崩れ修正”が主目的なので、以下はあなたの直前版をそのまま使ってください）
========================= */

/* ★★★ ここから下（generate() ～）は、あなたの直前の「全部入り」コードをそのまま貼って使ってOK ★★★ */
</script>

<!--
  重要：
  この回答は「モニターの見え方（折り返し禁止）」を直すための“完成版CSS”が主です。
  直前に渡したあなたの「全部入り」HTMLの <script> 内（generateやモニターJS）はそのまま残して、
  このファイルのCSS部分だけ差し替えるのが最短です。

  もし「本当に1枚に完全統合した全HTML」を今ここで再出力する必要があるなら
  そのまま言って。今の“直前の全部入り”をベースに、generate～末尾まで含めて丸ごと統合版を出す。
-->
</body>
</html>
